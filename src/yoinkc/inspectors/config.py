"""
Config inspector: RPM-owned modified (from rpm_va), unowned /etc files, orphaned configs.
Uses RPM section from snapshot for rpm_va and dnf_history_removed; executor for rpm -qla; pathlib for /etc.
When config_diffs=True, extracts original from RPM (dnf cache or host) and sets diff_against_rpm.
"""

import difflib
import fnmatch
from pathlib import Path
from typing import List, Optional, Set

from ..executor import Executor
from ..schema import ConfigFileEntry, ConfigFileKind, ConfigSection, RpmSection
from .._util import debug as _debug_fn, make_warning


def _debug(msg: str) -> None:
    _debug_fn("config", msg)

# ---------------------------------------------------------------------------
# System-generated files to exclude from the "unowned" list.
# These are created by systemd, package managers, or subsystem daemons —
# not operator-placed configs.  Easy to extend: add a path or glob pattern.
#
# TODO: consider adding --include-system-files to let operators opt into
#       seeing the full unfiltered list for auditing purposes.
# ---------------------------------------------------------------------------
_UNOWNED_EXCLUDE_EXACT: Set[str] = {
    # ── Machine identity (host-unique, never bake into an image) ────────────
    "/etc/machine-id",       # generated at first boot by systemd
    "/etc/adjtime",          # hardware clock state, host-specific
    "/etc/hostname",         # set at deploy time, not image-time
    "/etc/localtime",        # symlink managed by timedatectl, deploy-time

    # ── useradd / groupadd backup files ─────────────────────────────────────
    "/etc/.pwd.lock",
    "/etc/passwd-",
    "/etc/shadow-",
    "/etc/group-",
    "/etc/gshadow-",
    "/etc/subuid-",
    "/etc/subgid-",

    # ── systemd runtime state ────────────────────────────────────────────────
    "/etc/.updated",         # systemd timestamp touched on first boot
    "/etc/machine-info",     # written by hostnamectl, host-specific

    # ── standard systemd unit symlinks (created by systemd itself) ──────────
    "/etc/systemd/system/default.target",
    "/etc/systemd/system/dbus.service",
    "/etc/systemd/user/dbus.service",

    # ── Network / DNS ────────────────────────────────────────────────────────
    # resolv.conf provenance is handled by the network inspector
    "/etc/resolv.conf",
    # NM writes NetworkManager-intern.conf at runtime; not operator config
    "/etc/NetworkManager/NetworkManager-intern.conf",

    # ── ld.so / system library state ─────────────────────────────────────────
    "/etc/ld.so.cache",
    "/etc/ld.so.conf",       # not RPM-owned on RHEL 10
    "/etc/mtab",             # symlink to /proc/self/mounts
    "/etc/rpc",              # glibc system file, not RPM-owned on RHEL 10

    # ── Package manager state ────────────────────────────────────────────────
    "/etc/dnf/dnf.conf",
    "/etc/yum.conf",
    "/etc/npmrc",            # generated by nodejs package

    # ── Anaconda / installer artifacts ──────────────────────────────────────
    "/etc/sysconfig/anaconda",
    "/etc/sysconfig/kernel",           # generated by kernel package scripts
    "/etc/sysconfig/network",          # legacy stub, NM-managed
    "/etc/sysconfig/selinux",          # symlink to /etc/selinux/config
    "/etc/sysconfig/network-scripts/readme-ifcfg-rh.txt",

    # ── Bootloader / kernel ───────────────────────────────────────────────────
    "/etc/kernel/cmdline",

    # ── systemd standard targets ──────────────────────────────────────────────
    "/etc/systemd/system/ctrl-alt-del.target",

    # ── NVMe host identity (machine-unique) ───────────────────────────────────
    "/etc/nvme/hostnqn",
    "/etc/nvme/hostid",

    # ── Subscription manager / RHSM (host-specific) ──────────────────────────
    "/etc/rhsm/syspurpose/syspurpose.json",

    # ── OpenSSL configs (not RPM-owned on RHEL 10) ────────────────────────────
    "/etc/pki/tls/ct_log_list.cnf",
    "/etc/pki/tls/fips_local.cnf",
    "/etc/pki/tls/openssl.cnf",

    # ── SELinux policy store (compiled, not operator config) ──────────────────
    "/etc/selinux/targeted/setrans.conf",
    "/etc/selinux/targeted/seusers",
    "/etc/selinux/targeted/.policy.sha512",
    "/etc/selinux/targeted/booleans.subs_dist",

    # ── udisks2 defaults / examples ───────────────────────────────────────────
    "/etc/udisks2/udisks2.conf",
    "/etc/udisks2/mount_options.conf.example",

    # ── PAM base configs (RPM-owned on RHEL 9, not on 10) ─────────────────────
    "/etc/pam.d/chfn",
    "/etc/pam.d/chsh",
    "/etc/pam.d/login",
    "/etc/pam.d/remote",
    "/etc/pam.d/runuser",
    "/etc/pam.d/runuser-l",
    "/etc/pam.d/su",
    "/etc/pam.d/su-l",

    # ── tuned runtime state ──────────────────────────────────────────────────
    # These are written by the tuned daemon and reflect the active profile
    # at runtime, not operator-placed configuration.
    "/etc/tuned/active_profile",
    "/etc/tuned/profile_mode",
    "/etc/tuned/bootcmdline",
}

_UNOWNED_EXCLUDE_GLOBS: List[str] = [
    # ── RHEL subscription manager certs (product ID varies by version) ───────
    "/etc/pki/product-default/*.pem",

    # ── SSH host keys (machine-specific; content excluded by redaction too) ──
    "/etc/ssh/ssh_host_*",

    # ── alternatives system symlinks ────────────────────────────────────────
    "/etc/alternatives/*",

    # ── X11 fontpath cache ───────────────────────────────────────────────────
    "/etc/X11/fontpath.d/*",

    # ── SELinux compiled policy and context store (managed by semodule) ─────
    "/etc/selinux/*/policy/policy.*",
    "/etc/selinux/*/contexts/*",
    "/etc/selinux/*/contexts/files/*",
    "/etc/selinux/*/contexts/users/*",

    # ── udev hardware database (regenerated by systemd-hwdb) ─────────────────
    "/etc/udev/hwdb.bin",

    # ── PKI anchors and subscription certs ───────────────────────────────────
    "/etc/pki/ca-trust/extracted/*",
    "/etc/pki/java/cacerts",
    "/etc/pki/tls/cert.pem",
    "/etc/pki/tls/certs/ca-bundle.crt",
    "/etc/pki/tls/certs/ca-bundle.trust.crt",
    "/etc/pki/consumer/*",                # subscription-manager host cert
    "/etc/pki/entitlement/*",             # subscription entitlement certs

    # ── kernel / firmware transient configs ──────────────────────────────────
    "/etc/depmod.d/*-dist.conf",
    "/etc/modprobe.d/*-blacklist.conf",   # crypto-policies / kernel blacklists

    # ── authselect / dconf distro defaults ────────────────────────────────────
    "/etc/dconf/db/distro.d/*",
    "/etc/dconf/db/distro.d/locks/*",

    # ── dnf protected package lists (auto-generated) ──────────────────────────
    "/etc/dnf/protected.d/*",

    # ── gnupg profile scripts (package-generated) ─────────────────────────────
    "/etc/profile.d/gnupg2.*",

    # ── logrotate configs from packages (not RPM-owned on RHEL 10) ────────────
    "/etc/logrotate.d/kvm_stat",

    # ── systemctl enable/disable symlinks (service inspector handles these) ──
    "/etc/systemd/system/*.wants/*",
    "/etc/systemd/system/*.requires/*",
    "/etc/systemd/user/*.wants/*",
    "/etc/systemd/user/*.requires/*",

    # ── systemd vendor drop-ins ──────────────────────────────────────────────
    "/etc/systemd/sleep.conf.d/*",

    # ── LVM metadata (generated by lvm tools) ───────────────────────────────
    "/etc/lvm/archive/*",
    "/etc/lvm/backup/*",
    "/etc/lvm/devices/*",

    # ── firewalld backup files ───────────────────────────────────────────────
    "/etc/firewalld/zones/*.xml.old",
    "/etc/firewalld/*.xml.old",

    # ── NetworkManager generated state ──────────────────────────────────────
    # NM writes these internal state files itself; they are not operator config.
    # Operator drop-ins in conf.d/ are not excluded wholesale because operators
    # do place custom files there (e.g. 99-unmanaged-devices.conf).
    "/etc/NetworkManager/system-connections/*.nmconnection.bak",

    # ── Anaconda / installer glob artifacts ──────────────────────────────────
    "/etc/sysconfig/network-scripts/readme-*",

    # ── legacy power management hooks ───────────────────────────────────────
    "/etc/pm/sleep.d/*",
]


def _is_excluded_unowned(path: str) -> bool:
    """Return True if path matches the system-generated exclusion list."""
    if path in _UNOWNED_EXCLUDE_EXACT:
        return True
    for pattern in _UNOWNED_EXCLUDE_GLOBS:
        if fnmatch.fnmatch(path, pattern):
            return True
    return False


def _rpm_owned_paths(executor: Optional[Executor], host_root: Path, warnings: Optional[list] = None) -> Set[str]:
    """Build set of all RPM-owned paths under /etc in a single bulk query.

    Uses `rpm -qa --queryformat '[%{FILENAMES}\\n]'` to list every file owned by every
    installed package in one pass, then filters to /etc. This is O(1) RPM queries instead
    of O(n) per-package queries.
    """
    if executor is None:
        return set()
    dbpath = str(host_root / "var" / "lib" / "rpm")
    cmd = ["rpm", "--dbpath", dbpath, "-qa", "--queryformat", "[%{FILENAMES}\n]"]
    result = executor(cmd)
    if result.returncode != 0:
        cmd = ["rpm", "--root", str(host_root), "--define", "_rpmlock_path /var/tmp/.rpm.lock", "-qa", "--queryformat", "[%{FILENAMES}\n]"]
        result = executor(cmd)
    if result.returncode != 0:
        if warnings is not None:
            warnings.append(make_warning(
                "config",
                "rpm -qla failed — unowned file detection is unavailable. Config files not owned by any RPM package will not be captured.",
            ))
        return set()
    paths: Set[str] = set()
    for line in result.stdout.splitlines():
        p = line.strip()
        if p.startswith("/etc"):
            paths.add(p)
    return paths


def _list_etc_recursive(host_root: Path, etc_dir: Path) -> List[Path]:
    """List all files under etc_dir (relative to host_root)."""
    out = []
    try:
        for p in etc_dir.rglob("*"):
            if p.is_file():
                out.append(p)
    except Exception:
        pass
    return out


def _get_owning_package(executor: Executor, host_root: Path, path: str) -> Optional[str]:
    """Return package name owning path, or None."""
    if not executor:
        return None
    r = executor(["rpm", "--root", str(host_root), "-qf", path])
    if r.returncode != 0 or not r.stdout.strip():
        return None
    return r.stdout.strip().splitlines()[0].strip()


def _find_rpm_in_cache(host_root: Path, package_name: str) -> Optional[Path]:
    """Find RPM file in /var/cache/dnf for the given package name (exact name match)."""
    cache = host_root / "var" / "cache" / "dnf"
    if not cache.exists():
        return None
    prefix = package_name + "-"
    for rpm in cache.rglob("*.rpm"):
        if rpm.name.startswith(prefix) and len(rpm.name) > len(prefix) and rpm.name[len(prefix)].isdigit():
            return rpm
    return None


def _download_rpm_from_repo(executor: Executor, host_root: Path, package_name: str) -> Optional[Path]:
    """Download the RPM for *package_name* using dnf download (strategy 2).

    Returns the path to the downloaded .rpm file, or None on failure.
    """
    if not executor:
        return None
    tmp_dir = "/tmp/yoinkc-rpm-download"
    cmd = [
        "dnf", "download", "--destdir", tmp_dir,
        "--installroot", str(host_root),
        "--releasever=/",
        package_name,
    ]
    _debug(f"dnf download: {' '.join(cmd)}")
    r = executor(cmd)
    if r.returncode != 0:
        _debug(f"dnf download failed (rc={r.returncode}): {r.stderr.strip()[:200]}")
        return None
    try:
        tmp = Path(tmp_dir)
        prefix = package_name + "-"
        for rpm in tmp.glob("*.rpm"):
            if rpm.name.startswith(prefix):
                _debug(f"dnf download succeeded: {rpm}")
                return rpm
    except (PermissionError, OSError):
        pass
    return None


def _extract_file_from_rpm(executor: Executor, rpm_path: Path, path_in_rpm: str) -> Optional[str]:
    """Extract a single file from RPM via rpm2cpio | cpio. path_in_rpm is e.g. etc/httpd/conf/httpd.conf."""
    if not executor:
        return None
    cmd = ["sh", "-c", f"rpm2cpio {rpm_path!s} | cpio -i --to-stdout ./{path_in_rpm!s} 2>/dev/null"]
    _debug(f"extracting from RPM: {rpm_path.name} -> {path_in_rpm}")
    r = executor(cmd)
    if r.returncode != 0:
        _debug(f"rpm2cpio extraction failed (rc={r.returncode})")
        return None
    return r.stdout


def _unified_diff(original: str, current: str, path: str) -> str:
    """Produce unified diff string."""
    a = original.splitlines(keepends=True) or [""]
    b = current.splitlines(keepends=True) or [""]
    return "".join(
        difflib.unified_diff(a, b, fromfile="rpm", tofile="current", lineterm="")
    )


def run(
    host_root: Path,
    executor: Optional[Executor],
    rpm_section: Optional[RpmSection] = None,
    rpm_owned_paths_override: Optional[Set[str]] = None,
    config_diffs: bool = False,
    warnings: Optional[list] = None,
) -> ConfigSection:
    """
    Run Config inspection. Requires rpm_section for rpm_va and dnf_history_removed.
    If rpm_owned_paths_override is provided (e.g. from tests), use it; else compute via executor.
    """
    host_root = Path(host_root)
    section = ConfigSection()
    etc = host_root / "etc"
    if not etc.exists():
        return section

    rpm_va_paths: Set[str] = set()
    if rpm_section:
        for entry in rpm_section.rpm_va:
            if entry.path.startswith("/etc"):
                rpm_va_paths.add(entry.path)
        rpm_va_by_path = {e.path: e for e in rpm_section.rpm_va}
    else:
        rpm_va_by_path = {}

    # 1) RPM-owned modified files (from rpm_va)
    config_diff_failures = 0
    for path, entry in rpm_va_by_path.items():
        full = host_root / path.lstrip("/")
        if not full.exists():
            continue
        try:
            content = full.read_text()
        except Exception:
            content = ""
        diff_against_rpm = None
        if config_diffs and executor:
            pkg = _get_owning_package(executor, host_root, path) or entry.package
            path_in_rpm = path.lstrip("/")
            original = None

            # Strategy 1: local dnf cache
            rpm_path = _find_rpm_in_cache(host_root, pkg) if pkg else None
            if rpm_path:
                _debug(f"diff: found {pkg} in cache: {rpm_path}")
                original = _extract_file_from_rpm(executor, rpm_path, path_in_rpm)

            # Strategy 2: download from repos
            if original is None and pkg:
                rpm_path = _download_rpm_from_repo(executor, host_root, pkg)
                if rpm_path:
                    original = _extract_file_from_rpm(executor, rpm_path, path_in_rpm)

            if original is not None:
                diff_against_rpm = _unified_diff(original, content, path)
            else:
                _debug(f"diff: could not retrieve RPM default for {path}")
                config_diff_failures += 1
                content = (content or "") + "\n# NOTE: could not retrieve RPM default for diff — full file included\n"
        section.files.append(
            ConfigFileEntry(
                path=path,
                kind=ConfigFileKind.RPM_OWNED_MODIFIED,
                content=content,
                rpm_va_flags=entry.flags,
                package=entry.package,
                diff_against_rpm=diff_against_rpm,
            )
        )
    if config_diffs and config_diff_failures > 0 and warnings is not None:
        warnings.append(make_warning(
            "config",
            f"--config-diffs: {config_diff_failures} file(s) could not be diffed against RPM defaults (RPM not found in cache or repos) — full file content included instead.",
        ))

    # 2) Unowned files: in /etc but not in rpm_owned_paths
    if rpm_owned_paths_override is not None:
        rpm_owned = rpm_owned_paths_override
    else:
        rpm_owned = _rpm_owned_paths(executor, host_root, warnings=warnings)
    all_etc_files = _list_etc_recursive(host_root, etc)
    for f in all_etc_files:
        try:
            rel = f.relative_to(host_root)
            path_str = "/" + str(rel)
        except ValueError:
            continue
        if path_str in rpm_va_paths:
            continue  # already in modified
        if path_str in rpm_owned:
            continue
        if _is_excluded_unowned(path_str):
            continue
        try:
            content = f.read_text()
        except Exception:
            content = ""
        section.files.append(
            ConfigFileEntry(
                path=path_str,
                kind=ConfigFileKind.UNOWNED,
                content=content,
                rpm_va_flags=None,
                package=None,
                diff_against_rpm=None,
            )
        )

    # 3) Orphaned configs from removed packages. If dnf history records removed packages,
    # look for config files that match the package name pattern but aren't RPM-owned.
    if rpm_section and rpm_section.dnf_history_removed:
        seen_paths = {e.path for e in section.files}
        for pkg_name in rpm_section.dnf_history_removed:
            for pattern_dir in (etc,):
                try:
                    for f in pattern_dir.rglob(f"*{pkg_name}*"):
                        if not f.is_file():
                            continue
                        try:
                            rel = f.relative_to(host_root)
                            path_str = "/" + str(rel)
                        except ValueError:
                            continue
                        if path_str in seen_paths or path_str in rpm_owned:
                            continue
                        seen_paths.add(path_str)
                        try:
                            content = f.read_text()
                        except Exception:
                            content = ""
                        section.files.append(
                            ConfigFileEntry(
                                path=path_str,
                                kind=ConfigFileKind.ORPHANED,
                                content=content,
                                rpm_va_flags=None,
                                package=pkg_name,
                                diff_against_rpm=None,
                            )
                        )
                except Exception:
                    continue

    return section
