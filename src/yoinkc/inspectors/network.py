"""Network inspector: connections, firewall, DNS, proxy, routes, hosts.

File-based scan under host_root, plus ``ip route`` / ``ip rule`` via executor.
"""

import os
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Optional

from ..executor import Executor
from ..schema import (
    NetworkSection, NMConnection, FirewallZone, FirewallDirectRule,
    StaticRouteFile, ProxyEntry,
)
from .._util import safe_iterdir as _safe_iterdir, safe_read as _safe_read, make_warning


# ---------------------------------------------------------------------------
# NM connection classification
# ---------------------------------------------------------------------------

def _classify_connection(text: str) -> Dict[str, str]:
    """Extract method and type from a NM keyfile connection profile."""
    method = "unknown"
    conn_type = ""
    section = ""
    for line in text.splitlines():
        line = line.strip()
        if line.startswith("[") and line.endswith("]"):
            section = line[1:-1]
            continue
        if "=" not in line:
            continue
        key, _, val = line.partition("=")
        key, val = key.strip(), val.strip()
        if section == "ipv4" and key == "method":
            if val == "manual":
                method = "static"
            elif val == "auto":
                method = "dhcp"
            else:
                method = val
        if section == "connection" and key == "type":
            conn_type = val
    return {"method": method, "type": conn_type}


# ---------------------------------------------------------------------------
# Firewall parsing
# ---------------------------------------------------------------------------

def _parse_zone_xml(text: str) -> Dict[str, list]:
    """Parse a firewalld zone XML and extract services, ports, and rich rules."""
    services: List[str] = []
    ports: List[str] = []
    rich_rules: List[str] = []
    try:
        root = ET.fromstring(text)
    except ET.ParseError:
        return {"services": services, "ports": ports, "rich_rules": rich_rules}

    for svc in root.findall("service"):
        name = svc.get("name", "")
        if name:
            services.append(name)
    for port_el in root.findall("port"):
        proto = port_el.get("protocol", "")
        port_val = port_el.get("port", "")
        if port_val:
            ports.append(f"{port_val}/{proto}" if proto else port_val)
    for rule_el in root.findall("rule"):
        rich_rules.append(ET.tostring(rule_el, encoding="unicode").strip())

    return {"services": services, "ports": ports, "rich_rules": rich_rules}


def _parse_direct_xml(text: str) -> List[dict]:
    """Parse firewalld direct.xml and return list of direct rules."""
    results: List[dict] = []
    try:
        root = ET.fromstring(text)
    except ET.ParseError:
        return results
    for rule_el in root.findall("rule"):
        results.append({
            "ipv": rule_el.get("ipv", ""),
            "table": rule_el.get("table", ""),
            "chain": rule_el.get("chain", ""),
            "priority": rule_el.get("priority", "0"),
            "args": (rule_el.text or "").strip(),
        })
    return results


# ---------------------------------------------------------------------------
# resolv.conf provenance
# ---------------------------------------------------------------------------

def _detect_resolv_provenance(host_root: Path) -> str:
    r = host_root / "etc/resolv.conf"
    try:
        if not r.exists():
            return ""
        if r.is_symlink():
            # Use os.readlink to get the raw symlink target without following
            # it through the container's filesystem (which would resolve inside
            # the container, not on the host).
            target = os.readlink(str(r))
            if "systemd" in target or "resolve" in target:
                return "systemd-resolved"
        text = _safe_read(r)
        for line in text.splitlines():
            if "Generated by NetworkManager" in line:
                return "networkmanager"
        return "hand-edited"
    except (PermissionError, OSError):
        return ""


# ---------------------------------------------------------------------------
# ip route / ip rule
# ---------------------------------------------------------------------------

_DEFAULT_RULE_TABLES = {"local", "main", "default"}


def _parse_ip_routes(text: str) -> List[str]:
    return [ln.strip() for ln in text.splitlines() if ln.strip()]


def _parse_ip_rules(text: str) -> List[str]:
    """Return only non-default policy rules (skip local/main/default tables)."""
    results: List[str] = []
    for ln in text.splitlines():
        ln = ln.strip()
        if not ln:
            continue
        parts = ln.split()
        if "lookup" in parts:
            idx = parts.index("lookup")
            if idx + 1 < len(parts) and parts[idx + 1] in _DEFAULT_RULE_TABLES:
                continue
        results.append(ln)
    return results


# ---------------------------------------------------------------------------
# Main entry
# ---------------------------------------------------------------------------

def run(
    host_root: Path,
    executor: Optional[Executor],
    warnings: Optional[list] = None,
) -> NetworkSection:
    section = NetworkSection()
    host_root = Path(host_root)

    # --- NM connection profiles ---
    for subdir in ("etc/NetworkManager/system-connections", "etc/sysconfig/network-scripts"):
        d = host_root / subdir
        if not d.exists():
            continue
        for f in _safe_iterdir(d):
            if f.is_file() and not f.name.startswith("."):
                text = _safe_read(f)
                cls = _classify_connection(text)
                section.connections.append(NMConnection(
                    path=str(f.relative_to(host_root)),
                    name=f.stem,
                    method=cls["method"],
                    type=cls["type"],
                ))

    # --- Firewall zones ---
    fd = host_root / "etc/firewalld/zones"
    if fd.exists():
        try:
            fd.iterdir()  # probe readability
        except (PermissionError, OSError) as exc:
            if warnings is not None:
                warnings.append(make_warning(
                    "network",
                    f"Firewall zone directory unreadable ({exc}) — firewall configuration may be incomplete.",
                ))
        for f in _safe_iterdir(fd):
            if f.is_file() and f.suffix == ".xml":
                content = _safe_read(f)
                parsed = _parse_zone_xml(content)
                section.firewall_zones.append(FirewallZone(
                    path=str(f.relative_to(host_root)),
                    name=f.stem,
                    content=content,
                    services=parsed["services"],
                    ports=parsed["ports"],
                    rich_rules=parsed["rich_rules"],
                ))

    # --- Firewall direct rules ---
    direct_xml = host_root / "etc/firewalld/direct.xml"
    if direct_xml.exists():
        section.firewall_direct_rules = [
            FirewallDirectRule(**r) for r in _parse_direct_xml(_safe_read(direct_xml))
        ]

    # --- resolv.conf provenance ---
    section.resolv_provenance = _detect_resolv_provenance(host_root)

    # --- /etc/hosts ---
    hosts = host_root / "etc/hosts"
    try:
        if hosts.exists():
            for line in hosts.read_text().splitlines():
                line = line.strip()
                if line and not line.startswith("#") and "localhost" not in line.lower():
                    section.hosts_additions.append(line)
    except (PermissionError, OSError):
        pass

    # --- Static route files ---
    for route_dir in ("etc/sysconfig/network-scripts",):
        rd = host_root / route_dir
        if not rd.exists():
            continue
        for f in _safe_iterdir(rd):
            if f.is_file() and f.name.startswith("route-"):
                section.static_routes.append(StaticRouteFile(path=str(f.relative_to(host_root)), name=f.name))
    iproute_d = host_root / "etc/iproute2"
    if iproute_d.exists() and iproute_d.is_dir():
        for f in _safe_iterdir(iproute_d):
            if f.is_file():
                section.static_routes.append(StaticRouteFile(path=str(f.relative_to(host_root)), name=f.name))

    # --- ip route / ip rule via executor ---
    if executor:
        try:
            out = executor(["ip", "route"])
            if out.returncode == 0 and out.stdout:
                section.ip_routes = _parse_ip_routes(out.stdout)
            elif out.returncode != 0 and warnings is not None:
                warnings.append(make_warning(
                    "network",
                    "ip route failed — static route information unavailable.",
                ))
        except Exception:
            pass
        try:
            out = executor(["ip", "rule"])
            if out.returncode == 0 and out.stdout:
                section.ip_rules = _parse_ip_rules(out.stdout)
            elif out.returncode != 0 and warnings is not None:
                warnings.append(make_warning(
                    "network",
                    "ip rule failed — policy routing rule information unavailable.",
                ))
        except Exception:
            pass

    # --- Proxy ---
    for proxy_path in ("etc/environment", "etc/profile.d"):
        pp = host_root / proxy_path
        try:
            if pp.is_file():
                for line in pp.read_text().splitlines():
                    low = line.lower()
                    if any(k in low for k in ("http_proxy", "https_proxy", "no_proxy", "ftp_proxy")):
                        section.proxy.append(ProxyEntry(source=proxy_path, line=line.strip()))
            elif pp.is_dir():
                for f in _safe_iterdir(pp):
                    if f.is_file():
                        try:
                            for line in f.read_text().splitlines():
                                low = line.lower()
                                if any(k in low for k in ("http_proxy", "https_proxy", "no_proxy", "ftp_proxy")):
                                    section.proxy.append(ProxyEntry(source=str(f.relative_to(host_root)), line=line.strip()))
                        except (PermissionError, OSError):
                            pass
        except (PermissionError, OSError):
            pass

    # --- DNF proxy config ---
    _DNF_PROXY_KEYS = ("proxy", "proxy_username", "proxy_password", "proxy_auth_method")
    for dnf_conf_path in ("etc/dnf/dnf.conf", "etc/yum.conf"):
        dnf_conf = host_root / dnf_conf_path
        if not dnf_conf.is_file():
            continue
        try:
            for line in dnf_conf.read_text().splitlines():
                stripped = line.strip()
                if stripped.startswith("#") or "=" not in stripped:
                    continue
                key = stripped.split("=", 1)[0].strip().lower()
                if key in _DNF_PROXY_KEYS:
                    section.proxy.append(ProxyEntry(source=dnf_conf_path, line=stripped))
        except (PermissionError, OSError):
            pass

    return section
