"""
Containerfile renderer: produces Containerfile and config/ tree from snapshot.
"""

from pathlib import Path
from typing import Optional

from jinja2 import Environment

from ..schema import ConfigFileKind, InspectionSnapshot


def _base_image_from_os_release(snapshot: InspectionSnapshot) -> str:
    """Return FROM line base image based on os_release."""
    if not snapshot.os_release:
        return "registry.redhat.io/rhel9/rhel-bootc:9.6"
    osr = snapshot.os_release
    if osr.id == "rhel" and osr.version_id:
        return f"registry.redhat.io/rhel9/rhel-bootc:{osr.version_id}"
    if "centos" in osr.id.lower():
        return "quay.io/centos-bootc/centos-bootc:stream9"
    return "registry.redhat.io/rhel9/rhel-bootc:9.6"


def _write_config_tree(snapshot: InspectionSnapshot, output_dir: Path) -> None:
    """Write all config files from snapshot to output_dir/config/ preserving paths."""
    config_dir = output_dir / "config"
    if snapshot.config and snapshot.config.files:
        for entry in snapshot.config.files:
            rel = entry.path.lstrip("/")
            dest = config_dir / rel
            dest.parent.mkdir(parents=True, exist_ok=True)
            dest.write_text(entry.content or "")

    if snapshot.rpm and snapshot.rpm.repo_files:
        for repo in snapshot.rpm.repo_files:
            dest = config_dir / repo.path
            dest.parent.mkdir(parents=True, exist_ok=True)
            dest.write_text(repo.content or "")

    # Firewalld zones/services
    if snapshot.network and snapshot.network.firewall_zones:
        for z in snapshot.network.firewall_zones:
            path = z.get("path", "")
            content = z.get("content", "")
            if path:
                dest = config_dir / path
                dest.parent.mkdir(parents=True, exist_ok=True)
                dest.write_text(content)

    # Generated timer units from cron
    if snapshot.scheduled_tasks and snapshot.scheduled_tasks.generated_timer_units:
        systemd_dir = config_dir / "etc/systemd/system"
        systemd_dir.mkdir(parents=True, exist_ok=True)
        for u in snapshot.scheduled_tasks.generated_timer_units:
            name = u.get("name", "cron-timer")
            (systemd_dir / f"{name}.timer").write_text(u.get("timer_content", ""))
            (systemd_dir / f"{name}.service").write_text(u.get("service_content", ""))

    # Quadlet units (content from inspector; older snapshots may have path/name only)
    if snapshot.containers and snapshot.containers.quadlet_units:
        quadlet_dir = output_dir / "quadlet"
        quadlet_dir.mkdir(parents=True, exist_ok=True)
        for u in snapshot.containers.quadlet_units:
            name = u.get("name", "")
            content = u.get("content", "")
            if name and content:
                (quadlet_dir / name).write_text(content)

    # Non-RPM software files
    if snapshot.non_rpm_software and snapshot.non_rpm_software.items:
        for item in snapshot.non_rpm_software.items:
            path = item.get("path", "")
            content = item.get("content", "")
            if path and content:
                rel = path.lstrip("/")
                dest = config_dir / rel
                dest.parent.mkdir(parents=True, exist_ok=True)
                dest.write_text(content)

    # Kernel module / sysctl / dracut configs
    if snapshot.kernel_boot:
        for kpath in (snapshot.kernel_boot.modules_load_d or []):
            dest = config_dir / kpath
            dest.parent.mkdir(parents=True, exist_ok=True)
            if not dest.exists():
                dest.write_text("")
        for kpath in (snapshot.kernel_boot.modprobe_d or []):
            dest = config_dir / kpath
            dest.parent.mkdir(parents=True, exist_ok=True)
            if not dest.exists():
                dest.write_text("")
        for kpath in (snapshot.kernel_boot.dracut_conf or []):
            dest = config_dir / kpath
            dest.parent.mkdir(parents=True, exist_ok=True)
            if not dest.exists():
                dest.write_text("")

    # tmpfiles.d for /var (and home) directory structure
    tmpfiles_dir = config_dir / "etc/tmpfiles.d"
    tmpfiles_dir.mkdir(parents=True, exist_ok=True)
    tmpfiles_lines = [
        "# Generated by rhel2bootc: directories created on every boot.",
        "# /var is seeded at initial bootstrap only; bootc does not update it.",
        "# Add d lines for application dirs under /var or /home as needed.",
    ]
    if snapshot.users_groups and snapshot.users_groups.users:
        for u in snapshot.users_groups.users[:20]:
            name = u.get("name", "")
            if name and name != "root":
                tmpfiles_lines.append(f"d /home/{name} 0755 {name} - -")
    if len(tmpfiles_lines) <= 3:
        tmpfiles_lines.append("d /var/lib/app 0755 root root -")
    (tmpfiles_dir / "rhel2bootc-var.conf").write_text("\n".join(tmpfiles_lines) + "\n")


def _render_containerfile_content(snapshot: InspectionSnapshot) -> str:
    """Build Containerfile content from snapshot.

    Layer order matches the design doc for cache efficiency:
      repos → packages → services → firewall → scheduled tasks → configs →
      non-RPM software → quadlets → users → kernel → SELinux →
      network note → tmpfiles.d
    """
    lines = []
    base = _base_image_from_os_release(snapshot)
    lines.append("# === Base Image ===")
    os_desc = "unknown"
    if snapshot.os_release:
        os_desc = snapshot.os_release.pretty_name or snapshot.os_release.name or os_desc
    lines.append(f"# Detected: {os_desc}")
    lines.append(f"FROM {base}")
    lines.append("")

    # 1. Repository Configuration
    if snapshot.rpm and snapshot.rpm.repo_files:
        lines.append("# === Repository Configuration ===")
        lines.append(f"# Detected: {len(snapshot.rpm.repo_files)} repo file(s)")
        lines.append("COPY config/etc/yum.repos.d/ /etc/yum.repos.d/")
        if any("dnf" in r.path for r in snapshot.rpm.repo_files):
            lines.append("COPY config/etc/dnf/ /etc/dnf/")
        lines.append("")

    # 2. Package Installation
    if snapshot.rpm and snapshot.rpm.packages_added:
        names = sorted(set(p.name for p in snapshot.rpm.packages_added))
        lines.append("# === Package Installation ===")
        if getattr(snapshot.rpm, "no_baseline", False):
            lines.append("# No baseline — including all installed packages")
        else:
            lines.append(f"# Detected: {len(names)} packages added beyond baseline")
        lines.append("RUN dnf install -y \\")
        for n in names[:-1]:
            lines.append(f"    {n} \\")
        lines.append(f"    {names[-1]} \\")
        lines.append("    && dnf clean all")
        lines.append("")

    # 3. Service Enablement
    if snapshot.services:
        enabled = snapshot.services.enabled_units
        disabled = snapshot.services.disabled_units
        if enabled or disabled:
            lines.append("# === Service Enablement ===")
            lines.append(f"# Detected: {len(enabled)} non-default enabled, {len(disabled)} disabled")
            if enabled:
                lines.append("RUN systemctl enable " + " ".join(enabled))
            if disabled:
                lines.append("RUN systemctl disable " + " ".join(disabled))
            lines.append("")

    # 4. Firewall Configuration
    if snapshot.network and snapshot.network.firewall_zones:
        lines.append("# === Firewall Configuration ===")
        lines.append(f"# Detected: {len(snapshot.network.firewall_zones)} firewall zone(s)/service(s)")
        lines.append("COPY config/etc/firewalld/ /etc/firewalld/")
        lines.append("")

    # 5. Scheduled Tasks (generated timer units from cron)
    if snapshot.scheduled_tasks and snapshot.scheduled_tasks.generated_timer_units:
        lines.append("# === Scheduled Tasks ===")
        lines.append(f"# Converted from cron: {len(snapshot.scheduled_tasks.generated_timer_units)} timer(s)")
        lines.append("COPY config/etc/systemd/system/ /etc/systemd/system/")
        for u in snapshot.scheduled_tasks.generated_timer_units:
            name = u.get("name", "")
            if name:
                lines.append(f"RUN systemctl enable {name}.timer")
        lines.append("")
    elif snapshot.scheduled_tasks and (snapshot.scheduled_tasks.systemd_timers or snapshot.scheduled_tasks.cron_jobs):
        lines.append("# === Scheduled Tasks ===")
        lines.append("# Cron jobs present; no generated timer units (empty cron.d or parse skipped)")
        lines.append("")

    # 6. Configuration Files
    if snapshot.config and snapshot.config.files:
        modified = [f for f in snapshot.config.files if f.kind == ConfigFileKind.RPM_OWNED_MODIFIED]
        unowned = [f for f in snapshot.config.files if f.kind == ConfigFileKind.UNOWNED]
        has_diffs = any(f.diff_against_rpm for f in snapshot.config.files)
        lines.append("# === Configuration Files ===")
        lines.append(f"# Detected: {len(modified)} modified RPM-owned configs, {len(unowned)} unowned configs")
        if has_diffs:
            lines.append("# Config diffs (--config-diffs): see audit-report.md and report.html for per-file diffs.")
        for entry in snapshot.config.files:
            rel = entry.path.lstrip("/")
            if entry.diff_against_rpm and entry.diff_against_rpm.strip():
                pkg_label = entry.package or "RPM"
                diff_lines = [l for l in entry.diff_against_rpm.strip().splitlines() if l.startswith("+") or l.startswith("-")]
                diff_lines = [l for l in diff_lines if not l.startswith("---") and not l.startswith("+++")]
                summary = diff_lines[:5]
                lines.append(f"# Modified from {pkg_label} default:")
                for sl in summary:
                    lines.append(f"#   {sl}")
                if len(diff_lines) > 5:
                    lines.append(f"#   ... and {len(diff_lines) - 5} more changes")
                lines.append("# See audit-report.md or report.html for full diff")
            lines.append(f"COPY config/{rel} /{rel}")
        lines.append("")

    # 7. Non-RPM Software
    if snapshot.non_rpm_software and snapshot.non_rpm_software.items:
        lines.append("# === Non-RPM Software ===")

        pip_packages: list = []
        remaining: list = []

        for item in snapshot.non_rpm_software.items:
            method = item.get("method", "")
            if method == "pip dist-info" and item.get("version"):
                pip_packages.append((item["name"], item["version"]))
            elif method == "pip requirements.txt":
                path = item.get("path", "")
                lines.append(f"# FIXME: verify pip packages in /{path} install correctly from PyPI")
                lines.append(f"COPY config/{path} /{path}")
                lines.append(f"RUN pip install -r /{path}")
            elif method == "npm package-lock.json":
                path = item.get("path", "")
                lines.append(f"# FIXME: verify npm packages in /{path} install correctly")
                lines.append(f"COPY config/{path}/ /{path}/")
                lines.append(f"RUN cd /{path} && npm ci")
            elif method == "yarn.lock":
                path = item.get("path", "")
                lines.append(f"# FIXME: verify yarn packages in /{path} install correctly")
                lines.append(f"COPY config/{path}/ /{path}/")
                lines.append(f"RUN cd /{path} && yarn install --frozen-lockfile")
            elif method == "gem Gemfile.lock":
                path = item.get("path", "")
                lines.append(f"# FIXME: verify Ruby gems in /{path} install correctly")
                lines.append(f"COPY config/{path}/ /{path}/")
                lines.append(f"RUN cd /{path} && bundle install")
            else:
                remaining.append(item)

        if pip_packages:
            pip_packages.sort()
            lines.append(f"# Detected: {len(pip_packages)} pip package(s) via dist-info")
            lines.append("# FIXME: verify these pip packages install correctly from PyPI")
            lines.append("RUN pip install \\")
            for name, ver in pip_packages[:-1]:
                lines.append(f"    {name}=={ver} \\")
            name, ver = pip_packages[-1]
            lines.append(f"    {name}=={ver}")

        for item in remaining[:20]:
            path = item.get("path", item.get("name", ""))
            lines.append(f"# FIXME: unknown provenance — determine upstream source and installation method for /{path}")
            lines.append(f"# COPY config/{path} /{path}")

        lines.append("")

    # 8. Container Workloads (Quadlet)
    if snapshot.containers and (snapshot.containers.quadlet_units or snapshot.containers.compose_files):
        lines.append("# === Container Workloads (Quadlet) ===")
        if snapshot.containers.compose_files:
            lines.append("# FIXME: converted from docker-compose, verify quadlet translation")
        lines.append("COPY quadlet/ /etc/containers/systemd/")
        lines.append("")

    # 9. Users and Groups
    if snapshot.users_groups and (snapshot.users_groups.users or snapshot.users_groups.groups):
        lines.append("# === Users and Groups ===")
        for g in (snapshot.users_groups.groups or [])[:10]:
            name, gid = g.get("name", ""), g.get("gid", "")
            if name and gid:
                lines.append(f"RUN groupadd -g {gid} {name}")
        for u in (snapshot.users_groups.users or [])[:10]:
            name, uid, gid = u.get("name", ""), u.get("uid", ""), u.get("gid", "")
            shell = u.get("shell", "")
            if name and uid:
                gid_opt = f" -g {gid}" if gid else ""
                shell_opt = f" -s {shell}" if shell and shell != "/sbin/nologin" else ""
                lines.append(f"RUN useradd -u {uid}{gid_opt}{shell_opt} -m {name}")
        if snapshot.users_groups.ssh_authorized_keys_refs:
            lines.append("# NOTE: SSH authorized_keys detected — handle manually (do not bake keys into image)")
        lines.append("")

    # 10. Kernel Configuration
    has_kernel = snapshot.kernel_boot and (
        snapshot.kernel_boot.cmdline or snapshot.kernel_boot.modules_load_d
        or snapshot.kernel_boot.modprobe_d or snapshot.kernel_boot.dracut_conf
        or snapshot.kernel_boot.sysctl_overrides
    )
    if has_kernel:
        lines.append("# === Kernel Configuration ===")
        if snapshot.kernel_boot.cmdline:
            lines.append("# FIXME: review detected kernel args and add the ones needed for this image")
            lines.append("# RUN rpm-ostree kargs --append=<key>=<value>")
        if snapshot.kernel_boot.modules_load_d:
            lines.append(f"# Detected: {len(snapshot.kernel_boot.modules_load_d)} modules-load.d config(s)")
            lines.append("COPY config/etc/modules-load.d/ /etc/modules-load.d/")
        if snapshot.kernel_boot.modprobe_d:
            lines.append(f"# Detected: {len(snapshot.kernel_boot.modprobe_d)} modprobe.d config(s)")
            lines.append("COPY config/etc/modprobe.d/ /etc/modprobe.d/")
        if snapshot.kernel_boot.dracut_conf:
            lines.append(f"# Detected: {len(snapshot.kernel_boot.dracut_conf)} dracut.conf.d config(s)")
            lines.append("COPY config/etc/dracut.conf.d/ /etc/dracut.conf.d/")
        if snapshot.kernel_boot.sysctl_overrides:
            lines.append(f"# Detected: {len(snapshot.kernel_boot.sysctl_overrides)} sysctl override(s)")
            lines.append("COPY config/etc/sysctl.d/ /etc/sysctl.d/")
        lines.append("")

    # 11. SELinux Customizations
    has_selinux = snapshot.selinux and (
        snapshot.selinux.custom_modules or snapshot.selinux.boolean_overrides
        or snapshot.selinux.audit_rules or snapshot.selinux.fips_mode
    )
    if has_selinux:
        lines.append("# === SELinux Customizations ===")
        if snapshot.selinux.custom_modules:
            lines.append(f"# FIXME: {len(snapshot.selinux.custom_modules)} custom policy module(s) detected — "
                         "export .pp files to config/selinux/ and uncomment the COPY + semodule lines below")
            lines.append("# COPY config/selinux/ /tmp/selinux/")
            lines.append("# RUN semodule -i /tmp/selinux/*.pp && rm -rf /tmp/selinux/")
        if snapshot.selinux.boolean_overrides:
            lines.append(f"# FIXME: {len(snapshot.selinux.boolean_overrides)} custom boolean(s) detected — verify each is still needed")
            for b in snapshot.selinux.boolean_overrides[:10]:
                bname = b.get("name", "unknown_bool")
                bval = b.get("value", "on")
                lines.append(f"RUN setsebool -P {bname} {bval}")
        if snapshot.selinux.audit_rules:
            lines.append(f"# {len(snapshot.selinux.audit_rules)} audit rule file(s) detected")
            lines.append("COPY config/etc/audit/rules.d/ /etc/audit/rules.d/")
        if snapshot.selinux.fips_mode:
            lines.append("# FIXME: host has FIPS mode enabled — enable FIPS in the bootc image via fips-mode-setup")
        lines.append("")

    # 12. Network / Kickstart
    lines.append("# === Network / Kickstart ===")
    lines.append("# NOTE: Interface-specific config (DHCP, DNS) should be applied via kickstart at deploy time.")
    lines.append("# FIXME: review kickstart-suggestion.ks for deployment-time config")
    lines.append("")

    # 13. tmpfiles.d for /var structure
    lines.append("# === tmpfiles.d for /var structure ===")
    lines.append("# Directories created on every boot; /var is not updated by bootc after bootstrap.")
    lines.append("COPY config/etc/tmpfiles.d/ /etc/tmpfiles.d/")
    lines.append("")

    return "\n".join(lines)


def render(
    snapshot: InspectionSnapshot,
    env: Environment,
    output_dir: Path,
) -> None:
    """Write Containerfile and config/ tree to output_dir."""
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    _write_config_tree(snapshot, output_dir)
    content = _render_containerfile_content(snapshot)
    (output_dir / "Containerfile").write_text(content)
